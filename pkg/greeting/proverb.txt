Don't communicate by sharing memory, share memory by communicating.
Concurrency is not parallelism.
Channels orchestrate; mutexes serialize.
The bigger the interface, the weaker the abstraction.
Make the zero value useful.
interface{} says nothing.
Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.
A little copying is better than a little dependency.
Syscalls must always be guarded with build tags.
Cgo must always be guarded with build tags.
Cgo is not Go.
With the unsafe package there are no guarantees.
Clear is better than clever.
Reflection is never clear.
Errors are values.
Don't just check errors, handle them gracefully.
Design the architecture, name the components, document the details.
Documentation is for users.
Don't panic.
Make it work, make it right, make it fast.
Build constraints are for files, not functions.
The empty interface says nothing.
Write tests to learn.
The race detector is your friend.
Prefer composition over inheritance.
Accept interfaces, return structs.
Don't use goroutines in libraries.
Avoid package level state.
Simple is better than complex.
Explicit is better than implicit.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than right now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
Go is about composition, not inheritance.
Goroutines are cheap, but not free.
Don't start a goroutine without knowing how it will stop.
Channel ownership transfers responsibility.
Leave concurrency to the caller.
Before you launch a goroutine, know how it will stop.
Never start a goroutine without knowing when it will stop.
The best programs are written so that computing machines can perform them quickly and so that human beings can understand them clearly.
Programs must be written for people to read, and only incidentally for machines to execute.
Debugging is twice as hard as writing the code in the first place.
Everyone knows that debugging is twice as hard as writing a program in the first place.
So if you're as clever as you can be when you write it, how will you ever debug it?
The most important single aspect of software development is to be clear about what you are trying to build.
Wirth's law: Software is getting slower more rapidly than hardware becomes faster.
The cheapest, fastest, and most reliable components are those that aren't there.
One of my most productive days was throwing away 1000 lines of code.
Good code is its own best documentation.
Code never lies, comments sometimes do.
Any fool can write code that a computer can understand. Good programmers write code that humans can understand.
First, solve the problem. Then, write the code.
Experience is the name everyone gives to their mistakes.
In order to understand recursion, one must first understand recursion.
There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies.
The first 90% of the code accounts for the first 90% of the development time. The remaining 10% of the code accounts for the other 90% of the development time.
Adding manpower to a late software project makes it later.
A complex system that works is invariably found to have evolved from a simple system that worked.
If you want to set off and go develop some grand new thing, you don't need millions of dollars of capitalization. You need enough pizza and Diet Coke to stick in your refrigerator, a cheap PC to work on and the dedication to go through with it.